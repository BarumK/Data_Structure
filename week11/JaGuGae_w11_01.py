"""
-해싱의 사용 동기
<학번, 이름>으로 구성된 n명의 학생(데이터)들의 집합이 존재한다고 가정 (학번은 학생의 key)
    학생들이 학번에 관계없이 무작위로 저장되어있다고 가정 (ex: 이름순) -> 시간 복잡도: O(n), 선형검색을 사용해야 함
    학생들이 리스트에 학번 순으로 저장되어 있다고 가정 -> 시간 복잡도: O(logN), 이진 검색 사용 가능
    학생들이 이진 탐색 트리에 저장되어 있다고 가정 -> 시간 복잡도: 균형 이진 탐색 트리의 경우 O(logN), 편향되었을 경우 O(n)
시간 복잡도가 O(logN)보다 더 빠른 검색은 없을까? -> 학생들의 학번을 리스트의 인덱스로 사용 (direct addressing)
학번을 이용하여 특정 학생 이름을 검색하고자 한다면 시간 복잡도는 O(1). 하지만 메모리 낭비가 심함

-해싱 (hashing)
데이터의 키 값을 간단한 함수를 사용해 변환한, 즉 사상한(mapping) 값을 리스트의 인덱스(주소 공간)로 사용하여 데이터를 리스트에 저장하는 절차
공간 낭비를 줄이면서 키 값을 이용한 데이터 검색의 시간 복잡도를 가능하다면 O(1)로 유지하기 위해 사용
    해싱에 사용되는 함수를 해시 함수 (hash function)라 하고, 해시 함수가 계산한 값을 해시 값 (hash value) 또는 해시 주소 (hash value)
    라고 하며 데이터가 해시 값에 따라 저장된 구조를 해시 테이블 (hash table)이라고 함
    해시 함수를 통해 큰 키 공간 (key space or key domain)을 작은 주소 공간 (address space)로 변환
                   -> 키가 가질 수 있는 모든 집합           -> 배열의 인덱스
가장 널리 사용되는 해시 함수: 나눗셈 (division) 함수
    키 값을 소수(prime number) m으로 나눈 뒤, 그 나머지 값을 해시 값으로 사용. 여기서 m은 리스트의 사이즈.
        -> 리스트 사이즈보다 큰 키 값을 리스트 사이즈 범위에 포함되도록 변환하는 것이 목적
        -> 해시 값 h(key)는 key % m이므로 리스트의 인덱스 범위는 0부터 m - 1이 됨
    적절한 조치를 취한 해싱은 데이터의 수 n이 증가하여도 검색 시간에 영향을 주지 않음
    이상적일 경우 키 값을 이용하여 데이터를 검색할 경우 시간 복잡도는 O(1)
    해싱은 서로 다른 키 값을 가지는 데이터가 같은 해시 값을 가지게 되는 경우 충돌 (collision)이 발생

-주요 해시 함수
(1) 중간 제곱 (mid-square) 함수
    키 값을 제곱한 후, 적절한 크기의 중간 부분을 해시 값으로 사용
    여기서 적절한 크기란, 주소값(인덱스)이 가질 수 있는 자릿수임.
(2) 중첩 혹은 접기 (folding) 함수
    이동 접기(shift folding): 키 값을 마지막 부분을 모든 부분의 길이가 주소 공간의 자릿수와 동일하게 여러 부분으로 분할하고
                            이들의 합을 이용해 해시 값으로 사용
    경계 접기(boundary folding): 키 값을 마지막 부분을 제외한 모든 부분의 길이가 주소 공간의 자릿수와 동일하게 여러 부분으로 나누고
                                이들을 접고 (folding) 그 합을 이용해 해시 값으로 사용
(3) 곱셈 (multiplicative) 함수
    1보다 작은 실수 d(0.61803이 좋은 성능을 보임)를 키 값에 곱하여 얻은 숫자의 소수 부분을
    해시 테이블 크기 m과 곱한 값의 정수 부분을 해시 값으로 사용
(4) 숫자 분석 (digit analysis) 혹은 숫자 추출 함수
    키 값을 구성하는 각 숫자의 분포를 이용하는데 키 값들의 모든 자릿수에 대한 빈도 테이블을 만들고,
    어느 정도 균등한 분포를 갖는 자릿수의 조합을 해시 값으로 사용

-해싱을 위한 좋은 해시 함수의 조건
    해시 값이 주소 공간 내에 균등하게 분포되어야 함
    충돌 빈도가 잦지 않아야 함
    계산이 빨라야 함

-해시 테이블의 구조
해시 테이블 ht는 m개의 버킷 (bucket) ht[0], ht[1], ht[2], ... , ht[m - 1]로 이루어지는 테이블이며,
각 버킷은 s개의 슬롯(slot)을 가질 수 있음
해싱은 서로 다른 키 값을 가지는 데이터가 같은 해시 값을 가지게 되는 경우 충돌 (collision)이 발생하는데,
버킷이 가지는 슬롯 수보다 많이 충돌이 발생하게 되면 버킷에 더 이상 데이터를 저장할 수 없게 되는 오버플로우 (overflow) 가 발생함

-본 강의에서 가정하는 해시 테이블의 구조
본 강의에서 해시 테이블 ht는 m개의 슬롯 ht[0], ht[1], ht[2], ... , ht[m - 1]로 이루어진 리스트를 가정함
    -> 충돌을 해결할 방법이 반드시 필요함

-충돌 해결 방법: 선형 조사
삽입 연산 (insert)
    선형 조사는 삽입 시 충돌이 일어난 슬롯에서부터 순차적으로 방문하여 처음 발견한 empty 슬롯에 데이터를 삽입
        -검색하고자 하는 데이터의 키 값을 해시 함수를 통해 해시 테이블 ht의 인덱스 (해시 값) k로 변환 후 슬롯 k에 삽입 시 충돌이 발생했다면
         다음 위치의 슬롯인 ht[k - 1]부터 순차적으로 방문하여 비어 있는지를 조사하고, 빈 슬롯을 찾으면 데이터를 삽입
        -만약 ht의 끝에 도달하면 다시 ht의 처음 슬롯(즉, ht[0])으로 되돌아가서 조사
        -만약 조사 과정에서 처음 충돌이 발생한 슬롯 ht[k]로 다시 돌아왔다면 빈 슬롯이 없는 상태
        
-선형 조사 방법에서 데이터 삽입 시 문제점
충돌 시 순차적으로 빈 슬롯을 찾아 데이터를 저장하므로 해시 테이블 내의 데이터들이 빈틈없이 뭉쳐지는 군집화 (clustering) 현상이 발생
군집화 현상은 삽입, 검색, 삭제 연산 시 군집된 데이터들을 순차적으로 확인해야 하는, 즉 선형 검색과 유사하게 되는 문제점을 야기

-검색 연산
검색하고자 하는 데이터의 키 값을 해시 함수를 통해 해시 테이블 ht의 인덱스 (해시 값) k로 변환 후, 슬롯 ht[k]부터 시작하여
    (1) 데이터를 찾거나
    (2) 빈 슬롯을 만나거나 (== 검색 실패)
    (3) 모든 슬롯을 전부 방문할 때까지 순차적으로 인덱스 (해시 값)를 증가시켜 가면서 슬롯을 검사

-삭제 연산
검색 연산과 유사하게 삭제하고자 하는 데이터의 키 값을 해시 함수를 통해 해시 테이블 ht의 인덱스(해시 값) k로 변환 후, 슬롯 ht[k]부터 시작하여
    (1) 삭제할 데이터를 찾거나
    (2) 빈 슬롯을 만나거나
    (3) 모든 슬롯을 전부 방문할 때까지 순차적으로 검사 후 삭제.
단 빈 슬롯을 (1) 한번도 사용하지 않은 슬롯과
           (2) 사용되었다가 데이터가 삭제되어 현재 비어 있는 슬롯으로 구분해야 함(삽입, 검색 시에도 같은 상황 발생)
"""