"""
-정렬
탐색과 함께 컴퓨터가 가장 많이 수행하는 연산 중 하나로 순서 없이 나열된 항목들을 정렬 키 (sort key)를 기준으로 오름차순 혹은 내림차순으로 재배열시키는 연산
정렬은 탐색 성능을 향상시키기 위해서도 필수적임(ex: 이진 탐색)

-정렬 알고리즘 분류
내부 정렬(internal sort): 정렬할 항목들의 집합 D가 주기억장치(메인 메모리)에 상주할 수 있을 경우, D를 주기억장치에서 정렬
    선택 정렬: 평균 수행 시간 O(n^2)
    삽입 정렬: 평균 수행 시간 O(n^2)
    셸정렬: 정확한 수행 시간을 분석하기 어려움
    힙정렬: 평균 수행 시간 O(NlogN)
    합병정렬: 평균 수행 시간 O(NlogN)
    퀵정렬: 평균 수행 시간 O(NlogN)
외부 정렬(external sort): 정렬하고자 하는 항목들의 집합 D의 사이즈가 커서 보조기억장치(디스크)에 저장하고 이를 작은 크기의 부분 집합
                         D1, D2, ... , Dn으로 나누어 주기억장치에서 정렬하고 합병
본 강의는 (1) 내부 정렬 알고리즘에 초점을 맞추며
        (2) 오름차순 기준으로 정렬한다고 가정하고 가정하고
        (3) Python 리스트를 사용

-선택 정렬
리스트에서 아직 정렬되지 않은 부분의 원소(항목)들 중 최소인 원소를 '선택'하여 이미 정렬된 부분의 바로 오른쪽 원소와 교환(자리 이동)하는 정렬 알고리즘
선택 정렬 과정
    1. N개의 항목으로 이루어진 Python 리스트 items에서 가장 작은 원소를 찾음
    2. 가장 작은 원소가 items[j]라면 items[j]와 items[0](i = 0)의 위치를 서로 교환
    3. i를 증가시킨 후, items[0]을 제외한 나머지 원소들 중 가장 작은 원소 items[j]를 찾은 후, items[j]와 items[1](i = 1)의 위치를 서로 교환
    -> 위와 같은 과정을 반복 실행
선택 정렬 수행 시간 분석
    선택 정렬의 기본 연산 단위는 Phase로써 하나의 Phase마다 정렬되지 않은 부분에서 가장 작은 원소를 선택하여 교환
    첫 번째 Phase에서는 N개의 원소들 중에서 가장 작은 값을 찾기 위해 N - 1번 비교
    두 번째 Phase에서는 N - 1개의 원소들 중에서 가장 작은 값을 찾기 위해 N - 2번 비교
    같은 방법으로 마지막 Phase에서는 두 개의 원소를 1번 비교하여 가장 작은 값을 찾음
    따라서 원소들의 총 비교 횟수는: n * (n - 1) / 2 = O(n^2)
선택 정렬의 특징
    입력에 민감하지 않음(input insensitive): 어떠한 입력에 대해서도 항상 O(n^2) 수행 시간이 소요됨 -> 모든 경우의 분석이 가능하다
    값이 최소인 원소를 찾은 후 원소의 위치를 교환하는 최대 횟수가 N - 1번으로 정렬 알고리즘들 중에서 (최악의 경우) 가장 적은 위치 교환 횟수임

-삽입 정렬
리스트가 정렬된 부분과 정렬되지 않은 부분으로 나뉘며, 정렬되지 않은 부분의 가장 왼쪽 원소를 정렬된 부분 중 적절한 위치에 '삽입'하는 방식의 정렬 알고리즘
삽입 정렬 과정
    1. 리스트 items 내 N개의 원소 정렬 첫 원소 items[0]은 이미 정렬되었다고 취급
    2. 다음 원소 items[1]을 정렬된 부분 items[0]과 비교하여 적절한 위치에 삽입
    3. 다음 원소 items[2]를 정렬된 부분 items[0], items[1]과 비교하여 적절한 위치에 삽입
    -> 위와 같은 과정을 반복 실행
삽입 정렬 수행 시간 분석
    입력이 역으로 정렬되어 있는 경우(최악의 경우)
        첫 번째 단계에서는 한 번의 비교가 수행
        두 번째 단계에서는 두 번의 비교가 수행
        마지막 단계에서는 N - 1번의 비교가 수행
        따라서 원소들의 총 비교 횟수는: n * (n - 1) / 2 = O(n^2)
        원소를 교환하는 횟수도 n * (n - 1) / 2
    입력의 임의의 순서로 나열되어 있는 경우(평균의 경우)
        정렬되지 않은 부분의 가장 왼쪽 원소(현재 원소)가 정렬된 부분에 최종적으로 삽입되는 곳은 평균적으로 정렬된 부분의 중간이므로 (1 / 2) * n * (n - 1) / 2 = O(n^2)
삽입 정렬의 특징
    입력에 민감함(input sensitive): 입력에 따라 소요되는 수행 시간이 변함
        입력이 이미 정렬되어 있는 경우(최선의 경우), N - 1번 비교하면(교환 X) 정렬을 마치므로 O(N)
        입력이 역으로 정렬되어 있는 경우(최악의 경우) 혹은 임의의 순서로 나열되어 있는 경우 (평균의 경우) O(n^2)
    이미 정렬된 데이터의 뒷부분에 소량의 신규 데이터를 추가하여 정렬하는 경우(입력이 거의 정렬된 경우) 우수한 성능을 보임
    입력의 사이즈가 작은 경우 우수한 성능을 보임

-셸 정렬
리스트 내에서 일정한 간격 h로 떨어져 있는 원소들끼리 논리적인 서브리스트를 구성하고 각 서브리스트에 있는 원소들에 대해서 삽입 정렬을 수행하는 연산을 반복하면서 전체 원소들을 정렬하는 알고리즘
h-정렬
    간격이 h인 원소들로 구성된 h개의 서브리스트에 대해 삽입 정렬을 수행하는 알고리즘
셸 정렬은 h값(간격)을 줄여가며 여러 단계를 거쳐 h-정렬을 수행하고, 마지막엔 간격을 1로 하여 정렬
    h-정렬은 삽입 정렬을 수행하기 전에 작은 값을 가진 원소들을 리스트의 앞부분으로 옮기고, 큰 값을 가진 원소들이 리스트의 뒷부분으로 옮기는 전처리 과정임
    h = 1인 경우는 삽입 정렬과 동일 - 이미 부분적으로 정렬된 원소들의 수가 많아져서 매우 빠른 속도로 정렬이 됨
        -> 즉 셸 정렬은 '삽입 정렬은 입력이 거의 정렬된 경우 및 입력의 사이즈가 적은 경우 좋은 성능을 보인다'는 사실에 의해 고안된 정렬 알고리즘
셸 정렬 수행 시간 분석
    셸 정렬의 수행 시간은 h의 값에 따라 달라지므로 정확한 분석이 어려움
    일반적으로 입력의 사이즈가 작은 경우 좋은 성능을 보임

-힙 정렬
힙 정렬 과정
    1. Python 리스트 Max 힙으로 구성
    2. 루트 노드를 힙의 가장 마지막 노드와 교환한 후, 힙 사이즈(Python 리스트)를 1 감소시키고 노드 교환으로 인해 위배된 힙 속성을 downheap 연산으로 복원하는 과정을 힙 사이즈가 1이 될때까지 반복
힙 정렬 수행 시간 분석
    상향식(Bottom-up)으로 힙을 구성하는 시간: O(n)
    루트 노드와 힙의 마지막 노드를 교환한 후 downheap 수행 시간: O(logN)
    루트 노드와 힙의 마지막 노드를 교환하는 횟수: N - 1
    따라서 총 수행 시간은: O(N) + (N - 1) * O(logN) = O(NlogN)
힙 정렬의 특징
    입력에 민감하지 않음: 어떠한 입력에 대해서도 항상 O(NlogN) 수행 시간이 소요됨
    선택, 삽입, 쉘 정렬과 마찬가지로 정렬 시 추가 메모리 공간이 필요하지 않음
    (참고) 추가 메모리 공간 사용을 가정하여 힙 정렬을 구현하는 방법:
        오름차순 정렬의 경우 Min 힙을 구성 후, 힙이 empty가 될 때까지 extract_min 메소드를 이용하여 원소들을 하나씩 삭제 및 반환 후 빈 리스트에 append
    일반적으로 입력의 사이즈가 큰 경우 성능이 좋지 않음

-합병 정렬
(i) 하나의 리스트를 두 개의 균등한 크기의 서브리스트로 분할하고,
(ii) 각 서브리스트를 재귀적인 방식으로 합병 정렬을 수행하여 정렬한 다음,
(iii) 두 개의 정렬된 서브리스트를 합하여 전체가 정렬된 리스트가 되게 하는 정렬 알고리즘
합병 정렬 과정
    1. 리스트 items 내 N개의 원소 정렬 시 low, mid, high를 찾은 후 (여기서 low는 가장 왼쪽 인덱스, mid는 중간 인덱스, high는 가장 오른쪽 인덱스),
        두 서브리스트 items1[low, mid]와 items2[mid + 1, high]로 분할
    2. 모든 서브리스트의 사이즈가 1이 될 때까지 재귀적으로 분할
    3. 분할 과정이 끝나면, N개의 원소를 포함하는 하나의 리스트(정렬된 items)가 생성될 때까지 각각의 서브리스트를 결합 및 정렬
합병 정렬 수행 시간 분석
    입력 크기 N = 2^k라고 가정
    T(n): 크기가 N인 입력에 대해 합병 정렬이 수행하는 원소 비교 횟수(시간)
    T(n) = O(NlogN)
합병 정렬의 특징
    입력에 민감하지 않음: 어떠한 입력에 대해서도 항상 O(NlogN) 수행 시간이 소요됨
    정렬 시 추가 메모리 공간이 필요함
    자바 객체 정렬에서 시스템 sort로 활용

-퀵 정렬
(i) 하나의 리스트 내의 특정 원소 피봇(Pivot)을 기준으로 피봇보다 작은 원소들과 큰 원소들을 좌우로 분리하여 두 개의 비균등한 서브리스트 구성하고,
(ii) 각 서브리스트를 재귀적인 방식으로 퀵 정렬을 수행하여 정렬한 다음,
(iii) 두 개의 정렬된 서브리스트를 합하여 전체가 정렬된 리스트가 되게 하는 정렬 알고리즘
퀵 정렬 과정
    1. 리스트 items 내 N개의 원소 정렬 시 피봇을 선택(일반적으로 리스트의 첫 번쨰 원소)
    2. 피봇을 기준으로 피봇보다 작은 원소들을 피봇의 왼쪽으로 옮기고, 피봇보다 큰 요소들은 모두 피봇의 오른쪽으로 옮겨서 두 개의 서브 리스트를 생성(추가 공간 X)
    3. 피봇을 제외한 왼쪽 서브리스트와 오른쪽 서브리스트에 대해서도 서브리스트의 사이즈가 0이나 1이 될 때까지 재귀적으로 분할(합병 정렬과 다르게 퀵 정렬은 분할 시 정렬)
    4. 정렬된 서브리스트를 하나의 리스트로 자연스럽게 합병
퀵 정렬 수행 시간 분석
    입력 크기 N = 2^k라고 가정
    최선의 경우와 평균의 경우: O(NlogN)
        합병 정렬과 마찬가지로 k(= logN)만큼 분할하며, 각 분할마다 약 N번의 원소를 비교해야 하므로
    최악의 경우: O(n^2)
        입력이 이미 정렬되어 있거나 역순으로 정렬되어 있다면 N번 분할하며, 각 분할마다 약 N번의 원소를 비교해야 하므로
퀵 정렬의 특징
    평균 시간 복잡도가 O(NlogN)인 다른 정렬 알고리즘보다 빠름
    합병 정렬과 다르게 정렬 시 추가 메모리 공간이 필요하지 않음
    C언어 라이브러리의 qsort뿐만 아니라 Unix, g++, Visual C++ 등에서도 퀵 정렬을 시스템 sort로 사용

정렬 알고리즘 성능 비교
정렬              최선의 경우              평균의 경우              최악의 경우              추가 공간
선택 정렬          N^2                    N^2                    N^2                    필요 없음
삽입 정렬          N                      N^2                    N^2                    필요 없음
셸 정렬                                                                                 필요 없음
힙 정렬           NlogN                   NlogN                  NlogN                  필요 없음
합병 정렬         NlogN                   NlogN                  NlogN                  N만큼 필요
퀵 정렬           NlogN                   NlogN                  N^2                    필요 없음
"""