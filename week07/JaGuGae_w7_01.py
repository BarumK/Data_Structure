"""
-트리의 정의
아래의 조건을 만족하는 하나 이상의 노드(Node)들로 구성된 유한집합(Finite Set) T, 여기서 노드는 트리의 기본 단위(사용자 정의 데이터 타입)
    노드들 중에는 루트(Root)라 불리는 하나의 특별한 노드가 존재함
    루트를 제외한 나머지 노드들은 원소가 중복되지 않는 N(>=0)개의 부분 집합 T1, T2, ..., Tn으로 나누어 지며 Ti는 하나의 트리임
    이때 각 Ti를 트리 T의 서브트리라 부름

-트리의 필요성
선형 구조인 리스트롸 달리 비선형 구조인 트리는 계층 구조를 매우 효과적으로 표현함
선형 구조인 리스트보다 검색, 삽입, 삭제 연산의 시간 효율성을 증가시킬 수 있음(예: 이진 탐색 트리)
Python 리스트(통적 배열)의 경우 인덱스를 통한 항목 탐색 시 수행 시간이 O(1)이지만,
마지막 위치를 제외한 모든 위치에서의 항목 삽입, 삭제 시 수행 시간은 자리 이동으로 인해 O(n)
연결 리스트의 경우 삽입, 삭제 시 자리 이동이 필요 없지만, 항목 탐색 시 무조건 첫 노드부터 순회해야 하므로 O(n)
 -> 특히 정렬된 연결 리스트에서 이진 탐색 알고리즘을 적용해도 O(n)이므로 시간 효율적인 탐색이 목적이라면 정렬할 필요가 없음
트리는 head가 연결 리스트의 중간 노드의 참조를 저장하게 하고,
항목 탐색 시 연결 리스트의 중간 위치를 기준으로 탐색 범위를 재귀적으로 1/N씩 줄여나갈 수 있는 연결 리스트의 변형이라고 생각할 수도 있음
여기서 N은 트리 T의 각 노드가 저장할 수 있는 참조의 최대 수(즉, 각 노드의 링크 필드의 최대 수)

-트리의 용어
강의 PDF 참조

-트리의 왼쪽 자식 - 오른쪽 남매 표현
트리를 메모리에 저장하기 위해서는 트리의 각 노드 N에 대해 N의 키와 자식 수만큼의 참조를 저장해야 함
따라서 N은 가변적인 수의 참조를 저장하게 되지만
물리적 구현의 단순성을 위해서 모든 노드가 트리의 차수 K만큼의 참조를 저장할 수 있도록 하는 것이 바람직함
하지만 차수가 K인 트리 T에 존재하는 노드의 수가 N개일 때, None 값을 저장하고 있는 링크 필드의 수(즉, 낭비되는 링크 필드의 수)는 N*K-(N-1)임
여기서 N*K는 T에 존재하는 모든 링크 필드의 수이고 (N - 1)은 T에서 부모 노드와 자식 노드를 연결하는 참조의 수
K값이 클수록 메모리의 낭비가 심해지는 것은 물론 트리를 탐색하는 과정에서 참조가 None인 링크 필드도 확인해야 하므로
시간적으로도 매우 비효율적임(단, 메모리 기반 트리에 한함)
예를 들어, 교안의 트리는 29개의 링크 필드가 None값으로 채워지게 됨
-> 메모리 낭비가 심해짐

왼쪽 자식 - 오른쪽 남매 표현법은 K의 값을 2로 제한하여 트리를 표현할 수 있도록 만드는 방법임
각 노드는 자신의 제일 왼쪽 자식(자식이 하나면 그 자식)과 자신의 오른쪽 남매에 대한 두 개의 참조를 저장하기 위한 두 개의 링크 필드만을 가짐
"""